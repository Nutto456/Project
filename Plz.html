<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
    <title>Drowsiness Detection</title>
    <link rel="icon" href="data:,">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root { --safe-inset-bottom: env(safe-area-inset-bottom); }
        body { font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; }
        .video-wrap { position: relative; width: 100%; max-width: 560px; aspect-ratio: 3/4; }
        @media (max-width: 768px){ .video-wrap{ max-width:100%; aspect-ratio: unset; height: calc(100dvh - 120px); } }
        #video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
        #overlay { position: absolute; inset: 0; transform: scaleX(-1); }
        .action-bar { position: fixed; inset: auto 1rem 1rem 1rem; padding-bottom: calc(var(--safe-area-inset-bottom) + 0.5rem); }
        .status-badge { display: flex; align-items: center; justify-content: center; width: 2rem; height: 2rem; border-radius: 999px; }
        .indicator-group { position: fixed; top: 1rem; right: 1rem; z-index: 50; display: flex; gap: 0.5rem; padding: 0.5rem; background-color: rgba(0, 0, 0, 0.5); backdrop-filter: blur(8px); border-radius: 0.5rem; }
        .indicator-group svg { color: white; }
        .alert-popup { 
            position: fixed; 
            inset: 0; 
            z-index: 50; 
            display: none; 
            align-items: center; 
            justify-content: center; 
            padding: 1rem; 
            background-color: rgba(0, 0, 0, 0.7); 
            backdrop-filter: blur(4px);
            pointer-events: none;
        }
        .alert-popup.show { 
            display: flex;
        }
        .alert-popup .card { padding: 1.5rem; border-radius: 1.5rem; text-align: center; box-shadow: 0 10px 15px rgba(0,0,0,0.1); }
        .alert-popup .card.success { background-color: #10b981; }
        .alert-popup .card.error { background-color: #dc2626; }
        .alert-popup .card h2 { font-size: 1.5rem; font-weight: bold; color: white; margin-bottom: 0.5rem; }
        .alert-popup .card p { color: rgba(255, 255, 255, 0.8); }
        .alert-popup svg.animate-pulse { animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        #debug-info {
            position: fixed;
            bottom: 6rem;
            left: 1rem;
            padding: 0.5rem;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(8px);
            border-radius: 0.5rem;
            font-size: 0.75rem;
            color: white;
            z-index: 50;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/gh/alpinejs/alpine@v2.x.x/dist/alpine.min.js" defer></script>
</head>
<body class="bg-slate-900 min-h-screen text-white">
    <main class="mx-auto max-w-5xl p-4">
        <header class="mb-3 text-center">
            <h1 class="text-2xl font-bold">Drowsiness Detection</h1>
            <p class="text-slate-400 text-sm">ตรวจจับการหลับในแบบเรียลไทม์</p>
        </header>

        <section class="video-wrap mx-auto rounded-xl overflow-hidden bg-gray-800">
            <video id="video" autoplay playsinline muted></video>
            <canvas id="overlay"></canvas>
        </section>

        <div class="indicator-group">
            <div id="eyesStatus" class="status-badge bg-green-500">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6 text-white"><path d="M12 15a3 3 0 100-6 3 3 0 000 6z" /><path fill-rule="evenodd" d="M1.323 11.447C2.811 6.976 7.028 3.75 12.001 3.75c4.97 0 9.185 3.223 10.675 7.69.12.362.12.752 0 1.113-1.487 4.471-5.705 7.697-10.677 7.697-4.97 0-9.186-3.223-10.675-7.69a1.125 1.125 0 010-1.113zM12 17.25a5.25 5.25 0 100-10.5 5.25 5.25 0 000 10.5z" clip-rule="evenodd" /></svg>
            </div>
            <div id="phoneStatus" class="status-badge bg-green-500">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-5 h-5 text-white"><path fill-rule="evenodd" d="M1.5 4.5a3 3 0 013-3h15a3 3 0 013 3v13.5a3 3 0 01-3 3h-15a3 3 0 01-3-3V4.5zM15 15.75a.75.75 0 00.75.75h2.25a.75.75 0 00.75-.75V8.25a.75.75 0 00-.75-.75H15a.75.75 0 00-.75.75v7.5z" clip-rule="evenodd" /></svg>
            </div>
            <div id="wheelStatus" class="status-badge bg-green-500">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6 text-white"><path fill-rule="evenodd" d="M2.55 7.525a8.25 8.25 0 0110.152-4.144L12 4.582a6.75 6.75 0 00-8.237 3.328l-1.213-.385zM12 18a6 6 0 100-12 6 6 0 000 12zM11.25 9a.75.75 0 00-1.5 0v3.257a3 3 0 00-.776-.804l-1.724-1.725a.75.75 0 00-1.06 1.06l2.25 2.25a.75.75 0 001.06 0l2.25-2.25a.75.75 0 00-1.06-1.06l-1.725 1.724a3 3 0 00-.804.776V9z" clip-rule="evenodd" /><path d="M19.423 9.424a.75.75 0 00-.735-1.06l-2.434.646a.75.75 0 00-.372 1.455l2.062-.549.278.847a.75.75 0 001.442-.473L19.5 9.75l.138-.415.286.076a.75.75 0 00.347-1.458l-2.06-.549-.12.364a.75.75 0 00.223.882zM15.908 4.296a.75.75 0 00-.53-1.285l-1.21-.384a.75.75 0 00-.38.38l-.05.151.05.15a.75.75 0 00.38.38l1.21.385a.75.75 0 00.53-.38l.05-.15-.05-.15zM21.75 12a.75.75 0 00-.75-.75H19a.75.75 0 000 1.5h2A.75.75 0 0021.75 12zM17.25 20a.75.75 0 000 1.5h2a.75.75 0 000-1.5h-2zM12.75 22.5a.75.75 0 000 1.5h.75a.75.75 0 000-1.5h-.75z" /></svg>
            </div>
        </div>
        
        <div id="alertBox" class="alert-popup">
            <div id="alertCard" class="card error">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-24 h-24 mx-auto mb-2 text-white animate-pulse"><path fill-rule="evenodd" d="M9.401 3.003c1.155-2.06 4.017-2.06 5.173 0L21.41 12.87c1.155 2.059-.44 4.637-2.887 4.637H5.478c-2.447 0-4.042-2.578-2.886-4.637L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zM12 15a.75.75 0 100 1.5.75.75 0 000-1.5z" clip-rule="evenodd" /></svg>
                <h2 id="alertText"></h2>
                <p>กรุณาให้ความสนใจกับการขับขี่!</p>
            </div>
        </div>

        <div id="debug-info">
            Yawn Score: <span id="yawnScore">0.00</span>
        </div>

        <section class="action-bar flex gap-2">
            <button id="btnCalib" class="px-4 py-2 rounded-xl text-white bg-indigo-600 hover:bg-indigo-700 font-semibold shadow flex-1 disabled:bg-indigo-400">Calibrate</button>
            <button id="btnToggle" class="px-4 py-2 rounded-xl text-white bg-blue-600 hover:bg-blue-700 font-semibold shadow flex-1 disabled:bg-blue-400" disabled>Start</button>
        </section>
    </main>

    <script type="module">
        import { FaceDetector, HandLandmarker, ObjectDetector, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14";

        const video = document.getElementById('video');
        const canvas = document.getElementById('overlay');
        const ctx = canvas.getContext('2d');

        const btnToggle = document.getElementById('btnToggle');
        const btnCalib = document.getElementById('btnCalib');
        const alertBox = document.getElementById('alertBox');
        const alertText = document.getElementById('alertText');
        const alertCard = document.getElementById('alertCard');
        const eyesStatusIcon = document.getElementById('eyesStatus');
        const phoneStatusIcon = document.getElementById('phoneStatus');
        const wheelStatusIcon = document.getElementById('wheelStatus');
        const yawnScoreDisplay = document.getElementById('yawnScore');

        const THRESH = {
            EYE_CLOSED: 0.13,
            YAWN: 0.60,
            EYE_CLOSED_SEC: 1.0,
            YAWN_SEC: 1.5,
            BOTH_HANDS_UP_SEC: 2,
            PITCH_DOWN: 5, 
            PITCH_UP: -10,
            YAW_LEFT: 5, 
            YAW_RIGHT: -10,
            HOLD_SEC: 1.0,
            PHONE_SCORE: 0.50,
            PHONE_CADENCE: 12,
            WHEEL_OFF_ALERT_SEC: 2, 
            FACE_LOST_ALERT_SEC: 2.0
        };
        
        let isRunning = false, isBusy = false, lastTick = 0;
        let calibrated = false;
        let wheelOffStart = null; 

        let faceDetector, handLandmarker, objDetector;
        let modelsReady = false, phoneReady = false;

        let pitchOffset=0, yawOffset=0;
        let pitchStart=null, yawStart=null;
        let pitchEMA=null, yawEMA=null, rollEMA=null;
        let eyeStart=null, yawnStart=null, lastPhoneDetections = [];
        let faceLastSeen = null;

        let frameCount = 0;
        const poseGain = 1.2, yawGain = 2.0, pitchGain = 1.4;

        const ema = (p,v,a=0.35)=>(!Number.isFinite(v)?p:(p==null?v:a*v+(1-a)*p));
        const clamp=(v,lo,hi)=>Math.max(lo,Math.min(hi,v));
        const rad2deg=(r)=>r*57.2957795;
        const dist=(a,b)=>Math.hypot(a.x-b.x,a.y-b.y);
        const EAR=(l,r)=>(dist(l[1],l[5])+dist(l[2],l[4]))/(2*dist(l[0],l[3]));
        const MAR=(l,r,m)=>(dist(m[13],m[14])/(dist(m[61],m[291])+1e-6));

        function eulerFromR(r){ const r00=r[0],r01=r[1],r02=r[2]; const r10=r[3],r11=r[4],r12=r[5]; const r20=r[6],r21=r[7],r22=r[8]; const sy=Math.hypot(r00,r10); let pitch,yaw,roll; if(sy>1e-6){ pitch=Math.atan2(-r20,sy); yaw=Math.atan2(r10,r00); roll=Math.atan2(r21,r22);} else { pitch=Math.atan2(-r20,sy); yaw=Math.atan2(-r01,r11); roll=0;} return {pitch:rad2deg(pitch),yaw:rad2deg(yaw),roll:rad2deg(roll)}; }
        function poseFromMatrixAuto(m4){ if(!m4) return null; const a=Array.from(m4); if(a.length<16) return null; const Rr=[a[0],a[1],a[2], a[4],a[5],a[6], a[8],a[9],a[10]]; const Rc=[a[0],a[4],a[8], a[1],a[5],a[9], a[2],a[6],a[10]]; const er=eulerFromR(Rr), ec=eulerFromR(Rc); const mr=Math.abs(er.pitch)+Math.abs(er.yaw)+Math.abs(er.roll); const mc=Math.abs(ec.pitch)+Math.abs(ec.yaw)+Math.abs(ec.roll); const useCol=mc>mr*1.1; const e=useCol?ec:er; return { pitch:clamp(e.pitch,-60,60), yaw:clamp(e.yaw,-90,90), roll:clamp(e.roll,-60,60) }; }
        function poseSimple(lm){ const Leye=lm[33],Reye=lm[263],Nose=lm[1]; if(!Leye||!Reye||!Nose) return null; const midX=(Leye.x+Reye.x)/2, midY=(Leye.y+Reye.y)/2; const yaw=(Nose.x-midX)*260; const pitch=(midY-Nose.y)*360; return {pitch:clamp(pitch,-60,60),yaw:clamp(yaw,-90,90),roll:0}; }
        function resizeCanvas(){ const w=video.videoWidth||640, h=video.videoHeight||480; canvas.width=w; canvas.height=h; }
        window.addEventListener('resize',()=>{ if(video?.videoWidth) resizeCanvas(); });
        
        function collectHands(resH){
            const out=[];
            const lms = resH?.landmarks||[];
            const hd  = resH?.handednesses||[];
            for(let i=0;i<lms.length;i++){
                const lm = lms[i];
                const handed = hd?.[i]?.[0]?.categoryName || null;
                out.push({ lm, handedness: handed });
            }
            return out;
        }

        async function initModels(){
            if(modelsReady) return;
            const resolver = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm");

            // **Changed: Use FaceDetector instead of FaceLandmarker**
            faceDetector = await FaceDetector.createFromOptions(resolver,{
                baseOptions:{ modelAssetPath:"https://storage.googleapis.com/mediapipe-models/face_detector/blazeface_short_range/float16/1/blazeface_short_range.tflite" },
                runningMode:"VIDEO"
            });
            handLandmarker = await HandLandmarker.createFromOptions(resolver,{
                baseOptions:{ modelAssetPath:"https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/latest/hand_landmarker.task" },
                numHands:2, runningMode:"VIDEO"
            });
            objDetector = await ObjectDetector.createFromOptions(resolver,{
                baseOptions:{ modelAssetPath:"https://storage.googleapis.com/mediapipe-models/object_detector/efficientdet_lite0/float32/1/efficientdet_lite0.tflite" },
                scoreThreshold:THRESH.PHONE_SCORE, runningMode:"VIDEO", maxResults:5
            });
            modelsReady=true; phoneReady=true;
        }

        async function startCam(){
            try{
                const st = await navigator.mediaDevices.getUserMedia({
                    video:{ facingMode:"user", width:{ideal:1280}, height:{ideal:720}, frameRate:{ideal:30,max:30}},
                    audio:false
                });
                video.srcObject=st;
                await new Promise(r=>{ if(video.readyState>=1) r(); else video.onloadedmetadata=()=>r();});
                await video.play();
                resizeCanvas();
            }catch(err){
                console.error(err);
                alertText.textContent = "ไม่สามารถเปิดกล้องได้";
                alertCard.classList.remove('success');
                alertCard.classList.add('error');
                alertBox.classList.add('show');
                throw err;
            }
        }

        function updateStatusIcons(v){
            const alerts = [];
            eyesStatusIcon.style.backgroundColor = '';
            phoneStatusIcon.style.backgroundColor = '';
            wheelStatusIcon.style.backgroundColor = '';
            alertCard.classList.remove('success');
            alertCard.classList.add('error');

            if (v.eyeAlert) {
                eyesStatusIcon.style.backgroundColor = '#dc2626';
                alerts.push('ดวงตาปิด');
            }
            if (v.yawnAlert) {
                eyesStatusIcon.style.backgroundColor = '#dc2626';
                alerts.push('หาว');
            }
            if (v.phoneAlert) {
                phoneStatusIcon.style.backgroundColor = '#dc2626';
                alerts.push('ใช้โทรศัพท์');
            }
            if (v.wheelAlert) {
                wheelStatusIcon.style.backgroundColor = '#dc2626';
                alerts.push('ละมือจากพวงมาลัย');
            }
            if (v.faceLost) {
                alerts.push('ไม่พบใบหน้า');
            }
            
            if (v.yawAlertText) { alerts.push(v.yawAlertText); }
            if (v.pitchAlertText) { alerts.push(v.pitchAlertText); }
            
            if(alerts.length){
                alertText.textContent = alerts.join(' / ');
                alertBox.classList.add('show');
            } else {
                alertBox.classList.remove('show');
            }
        }

        const rVFC = video.requestVideoFrameCallback?.bind(video);
        function scheduleNext(loopFn){ if(rVFC) rVFC(()=>loopFn()); else requestAnimationFrame(loopFn); }
        const getFPS=()=>30;

        async function loop(){
            if(!isRunning) return;
            const now=performance.now();
            const budget=1000/getFPS();
            if(now-lastTick<budget){ return scheduleNext(loop);}
            lastTick=now;
            if(isBusy){ return scheduleNext(loop);}
            isBusy=true;

            try{
                const resF = faceDetector?.detectForVideo?.(video, now);
                const resH = handLandmarker?.detectForVideo?.(video, now);
                const hands = collectHands(resH);
                let eyeAlert=false, yawnAlert=false, phoneAlert=false, phone=false, wheelAlert=false;
                let faceLost=false;
                let yawAlertText='', pitchAlertText='';
                let yawnBlend = 0;

                ctx.clearRect(0,0,canvas.width,canvas.height);

                if(resF?.detections?.length > 0) {
                    const face = resF.detections[0];
                    const boundingBox = face.boundingBox;
                    const lm = face.landmarks || [];
                    
                    // **Calculate Yawn Score based on mouth distance**
                    const mouthTop = lm[0];
                    const mouthBottom = lm[1];
                    const mouthLeft = lm[2];
                    const mouthRight = lm[3];
                    const mouthDist = dist(mouthTop, mouthBottom);
                    const mouthWidth = dist(mouthLeft, mouthRight);
                    yawnBlend = mouthDist / (mouthWidth + 1e-6);

                    // **NOTE: `FaceDetector` does not have blendshapes or pose matrix, so we cannot do eye/pose detection here.**
                    // We need a more robust solution for all detections to work together.
                    // For now, let's focus on getting the Yawn detection working.

                    faceLastSeen = now/1000;
                } else {
                    const t = now/1000;
                    if(!faceLastSeen) faceLastSeen = t;
                    faceLost = (t - faceLastSeen > THRESH.FACE_LOST_ALERT_SEC);
                }

                if (yawnScoreDisplay) {
                    yawnScoreDisplay.textContent = yawnBlend.toFixed(2);
                }

                if(yawnBlend > THRESH.YAWN){ 
                    if(yawnStart==null) yawnStart=now; else if((now-yawnStart)/1000>THRESH.YAWN_SEC) yawnAlert=true; 
                } else { yawnStart=null; }

                frameCount++;
                let phoneBoxes = lastPhoneDetections;
                if(phoneReady && (frameCount % THRESH.PHONE_CADENCE === 0)){
                    const r = objDetector.detectForVideo(video, now);
                    const boxes=[];
                    for(const det of (r?.detections || [])){
                        const cat = det.categories?.[0]; if(!cat) continue;
                        const name=(cat.categoryName||'').toLowerCase(); if(name!=="cell phone") continue;
                        const bb=det.boundingBox; boxes.push({xMin:bb.originX,yMin:bb.originY,xMax:bb.originX+bb.width,yMax:bb.originY+bb.height,score:cat.score||0});
                    }
                    phoneBoxes = boxes; lastPhoneDetections = boxes;
                }
                if(phoneBoxes?.length){ phone = true; } else { phone=false; }
                phoneAlert = phone;
                
                if (hands.length > 0) {
                    wheelOffStart = null;
                } else {
                    if (wheelOffStart === null) {
                        wheelOffStart = now;
                    } else if ((now - wheelOffStart) / 1000 > THRESH.WHEEL_OFF_ALERT_SEC) {
                        wheelAlert = true;
                    }
                }
                
                updateStatusIcons({ eyeAlert, yawnAlert, phoneAlert, wheelAlert, faceLost, yawAlertText, pitchAlertText });

            }catch(e){ console.error('loop error',e); }
            finally{ isBusy=false; scheduleNext(loop); }
        }

        btnCalib.addEventListener('click', async ()=>{
            alertText.textContent = 'ฟังก์ชัน Calibrate ไม่สามารถใช้งานได้กับ FaceDetector';
            alertCard.classList.remove('success');
            alertCard.classList.add('error');
            alertBox.classList.add('show');
            setTimeout(()=>alertBox.classList.remove('show'), 2200);
        });

        btnToggle.addEventListener('click', async ()=>{
            if(!isRunning){
                try{
                    if(!video.srcObject) await startCam();
                    if(!modelsReady) await initModels();
                    isRunning = true; 
                    btnToggle.textContent='Stop';
                    btnCalib.disabled = true;
                    scheduleNext(loop);
                }catch(err){ 
                    console.error(err);
                    alertBox.classList.remove('active');
                    alertText.textContent = 'เริ่มไม่สำเร็จ: อนุญาตกล้อง/อินเทอร์เน็ต';
                    alertCard.classList.remove('success');
                    alertCard.classList.add('error');
                    alertBox.classList.add('show');
                }
            } else {
                isRunning = false; 
                btnToggle.textContent='Start';
                btnCalib.disabled = false;
                const s = video.srcObject; if(s){ s.getTracks().forEach(t=>t.stop()); video.srcObject=null; }
                ctx.clearRect(0,0,canvas.width,canvas.height);
                alertBox.classList.remove('active');
                alertText.textContent = 'หยุดการตรวจจับ';
                alertCard.classList.remove('success');
                alertCard.classList.add('error');
                alertBox.classList.add('show');
                setTimeout(()=>alertBox.classList.remove('show'), 2200);
            }
        });

        (async ()=>{
            try{
                await startCam();
                await initModels();
            }catch{}
        })();
    </script>
</body>
</html>