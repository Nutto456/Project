<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
  <title>Drowsiness Detection – มือถือหน้าเดียว (Calibrate ก่อนเริ่ม • 2 Hands)</title>
  <link rel="icon" href="data:,">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root { --safe-inset-bottom: env(safe-area-inset-bottom); }
    body { font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; }
    .video-wrap { position: relative; width: 100%; max-width: 540px; aspect-ratio: 3/4; }
    @media (max-width: 768px){ .video-wrap{ max-width:100%; aspect-ratio: unset; height: calc(100dvh - 184px); } }
    #video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
    #overlay { position: absolute; inset: 0; transform: scaleX(-1); }
    .sheet { position: fixed; inset: auto 0 0 0; background: white; border-top-left-radius: 1.25rem; border-top-right-radius: 1.25rem; box-shadow: 0 -16px 40px rgba(2,6,23,.2); transform: translateY(100%); transition: transform .25s ease; }
    .sheet.open { transform: translateY(0); }
    .action-bar { position: sticky; bottom: 0; inset-inline: 0; padding-bottom: calc(var(--safe-inset-bottom) + .5rem); }
    .badge { display:inline-block; padding:.15rem .5rem; border-radius:999px; font-size:.75rem; }
    .subtle { font-size:.80rem; color:#334155 }
  </style>
</head>
<body class="bg-slate-50 min-h-screen">
  <div id="toast" class="hidden fixed top-3 right-3 z-50 px-4 py-2 rounded-lg text-white shadow"></div>

  <main class="mx-auto max-w-5xl p-4">
    <header class="mb-3 text-center">
      <h1 class="text-2xl md:text-3xl font-bold">Drowsiness Detection</h1>
      <p class="text-slate-600 text-sm">หน้าเดียว ใช้งานง่าย • <span class="font-semibold">Calibrate ก่อนเริ่ม</span></p>
    </header>

    <section class="video-wrap mx-auto rounded-xl overflow-hidden bg-gray-200">
      <video id="video" autoplay playsinline muted></video>
      <canvas id="overlay"></canvas>
    </section>

    <!-- Status -->
    <section class="mt-3 grid grid-cols-2 gap-2 text-sm">
      <div class="col-span-2 flex flex-wrap gap-2 items-center">
        <span class="badge bg-blue-600 text-white" id="safeBadge">Head Pose: ON</span>
        <span class="badge bg-slate-200 text-slate-700" id="dbgMode">matrix: auto</span>
        <span class="badge bg-slate-200 text-slate-700" id="camBadge">cam: ?</span>
        <span class="badge bg-slate-200 text-slate-700" id="modelBadge">models: ?</span>
        <span class="badge bg-slate-200 text-slate-700" id="faceBadge">faces: 0</span>
      </div>
      <div>Pitch: <span id="pitchOut" class="font-semibold">-</span></div>
      <div>Yaw: <span id="yawOut" class="font-semibold">-</span></div>
      <div>Head LR: <span id="headLROut" class="font-semibold">-</span></div>
      <div>Head UD: <span id="headUDOut" class="font-semibold">-</span></div>
      <div>Eyes: <span id="eyesOut" class="font-semibold">-</span></div>
      <div>Yawn: <span id="yawnOut" class="font-semibold">-</span></div>
      <div>Hands: <span id="handsOut" class="font-semibold">-</span></div>
      <div>Phone: <span id="phoneOut" class="font-semibold">-</span></div>
      <p class="col-span-2 text-xs text-slate-500" id="scaleDbg">auto‑scale: yaw×1.00 pitch×1.00</p>
    </section>

    <!-- Alerts -->
    <section id="alertBox" class="hidden mt-3 p-3 rounded-xl bg-red-50 text-red-800 font-semibold"></section>

    <!-- Bottom actions (minimal) -->
    <section class="action-bar bg-white/90 backdrop-blur rounded-xl border border-slate-200 p-3 mt-3 flex items-center gap-2">
      <button id="btnCalib" class="px-4 py-2 rounded-xl text-white bg-indigo-600 hover:bg-indigo-700 font-semibold shadow flex-1">Calibrate</button>
      <button id="btnToggle" class="px-4 py-2 rounded-xl text-white bg-blue-600 hover:bg-blue-700 font-semibold shadow flex-1" disabled>Start</button>
      <button id="btnSettings" class="px-4 py-2 rounded-xl bg-slate-100 hover:bg-slate-200 font-semibold shadow">ตั้งค่า</button>
      <button id="btnFullscreen" class="px-4 py-2 rounded-xl bg-slate-100 hover:bg-slate-200 font-semibold shadow">Fullscreen</button>
    </section>
  </main>

  <!-- Settings Sheet -->
  <div id="sheet" class="sheet p-4">
    <div class="mx-auto max-w-xl">
      <div class="flex items-center justify-between mb-2">
        <h2 class="text-lg font-bold">ตั้งค่า</h2>
        <button id="btnCloseSheet" class="px-3 py-1 rounded-lg bg-slate-100">ปิด</button>
      </div>
      <div class="space-y-4 text-sm">
        <label class="flex items-center justify-between">
          <span>Flip Yaw</span>
          <input id="swFlipYaw" type="checkbox" class="scale-125" checked>
        </label>
        <label class="flex items-center justify-between">
          <span>Flip Pitch</span>
          <input id="swFlipPitch" type="checkbox" class="scale-125" checked>
        </label>
        <label class="flex items-center justify-between">
          <span>Phone Detector</span>
          <input id="swPhone" type="checkbox" class="scale-125" checked>
        </label>
        <label class="flex items-center justify-between">
          <span>นับว่า "กำลังใช้โทรศัพท์" เมื่อมือทับกรอบโทรศัพท์</span>
          <input id="swPhoneOverlap" type="checkbox" class="scale-125" checked>
        </label>
        <details>
          <summary class="cursor-pointer select-none font-semibold">ขั้นสูง</summary>
          <div class="mt-2 space-y-3">
            <label class="flex items-center justify-between gap-3"><span>FPS</span>
              <select id="fps" class="border rounded px-2 py-1">
                <option>24</option>
                <option selected>30</option>
                <option>20</option>
                <option>15</option>
              </select>
              <span id="cpuHint" class="text-xs text-slate-500"></span>
            </label>
            <label class="flex items-center justify-between gap-3"><span>Pose Gain</span>
              <input id="poseGain" type="range" min="0.80" max="2.00" step="0.05" value="1.20" class="w-40">
              <span id="poseGainLabel" class="tabular-nums">1.20×</span>
            </label>
            <label class="flex items-center justify-between gap-3"><span>Yaw Gain</span>
              <input id="yawGain" type="range" min="0.50" max="4.00" step="0.10" value="2.00" class="w-40">
              <span id="yawGainLabel" class="tabular-nums">2.00×</span>
            </label>
            <label class="flex items-center justify-between gap-3"><span>Pitch Gain</span>
              <input id="pitchGain" type="range" min="0.50" max="4.00" step="0.10" value="1.40" class="w-40">
              <span id="pitchGainLabel" class="tabular-nums">1.40×</span>
            </label>
          </div>
        </details>
      </div>
    </div>
  </div>

  <!-- sounds -->
  <audio id="sndEyes"  src="./static/Sound/eyeclosed_alert.mp3" preload="auto"></audio>
  <audio id="sndYawn"  src="./static/Sound/Yawn_alert.mp3" preload="auto"></audio>
  <audio id="sndHands" src="./static/Sound/both_hand_alert.mp3" preload="auto"></audio>
  <audio id="sndPhone" src="./static/Sound/phone_alert.mp3" preload="auto"></audio>

  <script type="module">
    import { FaceLandmarker, HandLandmarker, ObjectDetector, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14";

    // --- Elements
    const video = document.getElementById('video');
    const canvas = document.getElementById('overlay');
    const ctx = canvas.getContext('2d');

    const btnToggle = document.getElementById('btnToggle');
    const btnCalib = document.getElementById('btnCalib');
    const btnFullscreen = document.getElementById('btnFullscreen');
    const btnSettings = document.getElementById('btnSettings');

    const sheet = document.getElementById('sheet');
    const btnCloseSheet = document.getElementById('btnCloseSheet');

    const swFlipYaw = document.getElementById('swFlipYaw');
    const swFlipPitch = document.getElementById('swFlipPitch');
    const swPhone = document.getElementById('swPhone');
    const swPhoneOverlap = document.getElementById('swPhoneOverlap');

    const fpsSel = document.getElementById('fps');
    const poseGainEl = document.getElementById('poseGain');
    const yawGainEl = document.getElementById('yawGain');
    const pitchGainEl = document.getElementById('pitchGain');
    const poseGainLabel = document.getElementById('poseGainLabel');
    const yawGainLabel = document.getElementById('yawGainLabel');
    const pitchGainLabel = document.getElementById('pitchGainLabel');

    const safeBadge = document.getElementById('safeBadge');
    const dbgMode = document.getElementById('dbgMode');
    const camBadge = document.getElementById('camBadge');
    const modelBadge = document.getElementById('modelBadge');
    const faceBadge = document.getElementById('faceBadge');
    const scaleDbg = document.getElementById('scaleDbg');
    const cpuHint = document.getElementById('cpuHint');
    const toast = document.getElementById('toast');
    const alertBox = document.getElementById('alertBox');

    const pitchOut = document.getElementById('pitchOut');
    const yawOut   = document.getElementById('yawOut');
    const headLROut = document.getElementById('headLROut');
    const headUDOut = document.getElementById('headUDOut');
    const eyesOut  = document.getElementById('eyesOut');
    const yawnOut  = document.getElementById('yawnOut');
    const handsOut = document.getElementById('handsOut');
    const phoneOut = document.getElementById('phoneOut');

    const sndEyes  = document.getElementById('sndEyes');
    const sndYawn  = document.getElementById('sndYawn');
    const sndHands = document.getElementById('sndHands');
    const sndPhone = document.getElementById('sndPhone');


    // --- Config
    const THRESH = {
      EYE_CLOSED: 0.13,
      YAWN: 0.60,
      EYE_CLOSED_SEC: 1.0,
      YAWN_SEC: 2.5,
      BOTH_HANDS_UP_SEC: 2,
      PITCH_DOWN: 15,
      PITCH_UP: -18,
      YAW_LEFT: 10,
      YAW_RIGHT: -15,
      HOLD_SEC: 1.0,
      PHONE_SCORE: 0.50,
      PHONE_CADENCE: 12
    };

    // --- State
    let isRunning = false, isBusy = false, lastTick = 0;
    let calibrated = false;
    let flipYaw = true, flipPitch = true; // default ON per your preference

    let faceLandmarker, handLandmarker, objDetector;
    let modelsReady = false, phoneReady = false;

    let pitchOffset=0, yawOffset=0;
    let pitchEMA=null, yawEMA=null, rollEMA=null;
    let eyeStart=null, yawnStart=null, handsStart=null, yawStart=null, pitchStart=null;
    let playing = new Set();

    let frameCount = 0; let lastPhoneDetections = [];

    let sYawAuto = 1.0, sPitchAuto = 1.0;
    let warmupFrames = 90; let earBase=null, marBase=null;

    const winYaw=[], winPitch=[]; const WIN=5;
    let wakeLock=null;

    // --- Utils
    const ema = (p,v,a=0.35)=>(!Number.isFinite(v)?p:(p==null?v:a*v+(1-a)*p));
    const clamp=(v,lo,hi)=>Math.max(lo,Math.min(hi,v));
    const rad2deg=(r)=>r*57.2957795;
    const median=(arr)=>{const a=[...arr].sort((x,y)=>x-y); const n=a.length; return n? (n%2?a[(n-1)/2]:(a[n/2-1]+a[n/2])/2):null};
    const showToast=(m,ok=true)=>{ toast.textContent=m; toast.className=`fixed top-3 right-3 z-50 px-4 py-2 rounded-lg text-white shadow ${ok?'bg-green-600':'bg-red-600'}`; toast.classList.remove('hidden'); setTimeout(()=>toast.classList.add('hidden'),2200); };
    function playLoop(id, el){ if(!playing.has(id)){ el.loop=true; el.play().catch(()=>{}); playing.add(id);} }
    function stopLoop(id, el){ if(playing.has(id)){ el.pause(); el.currentTime=0; playing.delete(id);} }
    function stopAll(){ stopLoop('EYES',sndEyes); stopLoop('YAWN',sndYawn); stopLoop('HANDS',sndHands); stopLoop('PHONE',sndPhone); }

    const L={ LEFT_EYE:[33,160,158,133,153,144], RIGHT_EYE:[263,387,385,362,380,373], MOUTH:[78,95,88,178,87,14,317,402,318,324,308,415,13,312,311,310,415,308,402,317] };
    const dist=(a,b)=>Math.hypot(a.x-b.x,a.y-b.y);
    const ear=(lm,i)=>(dist(lm[i[1]],lm[i[5]])+dist(lm[i[2]],lm[i[4]]))/(2*dist(lm[i[0]],lm[i[3]]));
    const mar=(lm,i)=>(dist(lm[i[13]],lm[i[19]])+dist(lm[i[14]],lm[i[18]]))/(2*dist(lm[i[12]],lm[i[16]]));

    function handsAboveFace(hands,face){ if(!hands?.length||!face?.length) return {count:0,both:false}; const faceMinY=Math.min(...face.map(p=>p.y)); let c=0; for(const h of hands){ const minY=Math.min(...h.map(p=>p.y)); if(minY<faceMinY) c++; } return {count:c,both:c>=2}; }
    function eulerFromR(r){ const r00=r[0],r01=r[1],r02=r[2]; const r10=r[3],r11=r[4],r12=r[5]; const r20=r[6],r21=r[7],r22=r[8]; const sy=Math.hypot(r00,r10); let pitch,yaw,roll; if(sy>1e-6){ pitch=Math.atan2(-r20,sy); yaw=Math.atan2(r10,r00); roll=Math.atan2(r21,r22);} else { pitch=Math.atan2(-r20,sy); yaw=Math.atan2(-r01,r11); roll=0;} return {pitch:rad2deg(pitch),yaw:rad2deg(yaw),roll:rad2deg(roll)}; }
    function poseFromMatrixAuto(m4){ if(!m4) return null; const a=Array.from(m4); if(a.length<16) return null; const Rr=[a[0],a[1],a[2], a[4],a[5],a[6], a[8],a[9],a[10]]; const Rc=[a[0],a[4],a[8], a[1],a[5],a[9], a[2],a[6],a[10]]; const er=eulerFromR(Rr), ec=eulerFromR(Rc); const mr=Math.abs(er.pitch)+Math.abs(er.yaw)+Math.abs(er.roll); const mc=Math.abs(ec.pitch)+Math.abs(ec.yaw)+Math.abs(ec.roll); const useCol=mc>mr*1.1; dbgMode.textContent=`matrix: ${useCol?'col-major':'row-major'}`; const e=useCol?ec:er; return { pitch:clamp(e.pitch,-60,60), yaw:clamp(e.yaw,-90,90), roll:clamp(e.roll,-60,60) }; }
    function poseSimple(lm){ const Leye=lm[33],Reye=lm[263],Nose=lm[1]; if(!Leye||!Reye||!Nose) return null; const midX=(Leye.x+Reye.x)/2, midY=(Leye.y+Reye.y)/2; const yaw=(Nose.x-midX)*260; const pitch=(midY-Nose.y)*360; return {pitch:clamp(pitch,-60,60),yaw:clamp(yaw,-90,90),roll:0}; }

    function resizeCanvas(){ const w=video.videoWidth||640, h=video.videoHeight||480; canvas.width=w; canvas.height=h; }
    window.addEventListener('resize',()=>{ if(video?.videoWidth) resizeCanvas(); });

    async function initModels(){ if(modelsReady) return; const resolver = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm");
      faceLandmarker = await FaceLandmarker.createFromOptions(resolver,{ baseOptions:{ modelAssetPath:"https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/latest/face_landmarker.task" }, numFaces:1, runningMode:"VIDEO", outputFaceBlendshapes:false, outputFacialTransformationMatrixes:true});
      // ✅ เปลี่ยนให้ตรวจสองมือ
      handLandmarker = await HandLandmarker.createFromOptions(resolver,{ baseOptions:{ modelAssetPath:"https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/latest/hand_landmarker.task" }, numHands:2, runningMode:"VIDEO"});
      objDetector = await ObjectDetector.createFromOptions(resolver,{ baseOptions:{ modelAssetPath:"https://storage.googleapis.com/mediapipe-models/object_detector/efficientdet_lite0/float32/1/efficientdet_lite0.tflite" }, scoreThreshold:THRESH.PHONE_SCORE, runningMode:"VIDEO", maxResults:5});
      modelsReady=true; phoneReady=true; modelBadge.textContent='models: ok'; modelBadge.className='badge bg-green-600 text-white'; }

    async function startCam(){ try{ const st = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:"user", width:{ideal:1280}, height:{ideal:720}, frameRate:{ideal:30,max:30}}, audio:false }); video.srcObject=st; await new Promise(r=>{ if(video.readyState>=1) r(); else video.onloadedmetadata=()=>r();}); await video.play(); resizeCanvas(); camBadge.textContent='cam: ok'; camBadge.className='badge bg-green-600 text-white'; }catch(err){ console.error(err); showToast('ไม่สามารถเปิดกล้องได้: อนุญาตการใช้งานกล้อง',false); camBadge.textContent='cam: blocked'; camBadge.className='badge bg-red-600 text-white'; throw err; } }

    // --- UI
    function updateUI(v){ const fmt=(x)=>Number.isFinite(x)?x.toFixed(1):'-'; pitchOut.textContent=fmt(v.pitch); yawOut.textContent=fmt(v.yaw); headLROut.textContent=v.headLR??'-'; headUDOut.textContent=v.headUD??'-'; eyesOut.textContent=v.eyeStatus??'-'; yawnOut.textContent=v.yawnStatus??'-'; handsOut.textContent=v.handStatus??'-'; phoneOut.textContent=v.phone? 'Yes':'No'; const alerts=[]; if(v.eyeAlert) alerts.push('Eyes Closed!'); if(v.yawnAlert) alerts.push('Yawning!'); if(v.handsAlert) alerts.push('Both Hands Up!'); if(v.phoneAlert) alerts.push('Using Phone!'); if(v.yawAlertText) alerts.push(v.yawAlertText); if(v.pitchAlertText) alerts.push(v.pitchAlertText); if(alerts.length){ alertBox.classList.remove('hidden'); alertBox.innerHTML=alerts.map(a=>`<p>${a}</p>`).join(''); } else { alertBox.classList.add('hidden'); alertBox.innerHTML=''; } alerts.includes('Eyes Closed!')?playLoop('EYES',sndEyes):stopLoop('EYES',sndEyes); alerts.includes('Yawning!')?playLoop('YAWN',sndYawn):stopLoop('YAWN',sndYawn); alerts.includes('Both Hands Up!')?playLoop('HANDS',sndHands):stopLoop('HANDS',sndHands); alerts.includes('Using Phone!')?playLoop('PHONE',sndPhone):stopLoop('PHONE',sndPhone); }

    const rVFC = video.requestVideoFrameCallback?.bind(video);
    function scheduleNext(loopFn){ if(rVFC) rVFC(()=>loopFn()); else requestAnimationFrame(loopFn); }
    const getFPS=()=>Number(fpsSel?.value)||30;
    const medianPush=(win,v)=>{ if(!Number.isFinite(v)) return v; win.push(v); if(win.length>WIN) win.shift(); const a=[...win].sort((x,y)=>x-y); const n=a.length; return n?(n%2?a[(n-1)/2]:(a[n/2-1]+a[n/2])/2):v; };
    function adaptCpu(){ const fps=getFPS(); const cadence=Math.max(8, Math.round((fps/30)*THRESH.PHONE_CADENCE)); THRESH.PHONE_CADENCE=cadence; cpuHint && (cpuHint.textContent=`• phone every ${cadence}f`); }

    async function loop(){ if(!isRunning) return; const now=performance.now(); const budget=1000/getFPS(); if(now-lastTick<budget){ return scheduleNext(loop);} lastTick=now; if(isBusy){ return scheduleNext(loop);} isBusy=true; adaptCpu();
      try{
        const resF = faceLandmarker?.detectForVideo?.(video, now);
        const resH = handLandmarker?.detectForVideo?.(video, now);
        faceBadge.textContent = `faces: ${resF?.faceLandmarks?.length||0}`;
        const face = resF?.faceLandmarks?.[0] || null;
        const hands = (resH?.landmarks||[]).map(x=>x);

        let pitch=null,yaw=null; let eyeStatus='-', yawnStatus='-', handStatus='No Hands';
        let eyeAlert=false,yawnAlert=false,handsAlert=false,phoneAlert=false,phone=false; let headLR='Center', headUD='Center', yawAlertText='', pitchAlertText='';

        ctx.clearRect(0,0,canvas.width,canvas.height);
        if(face){
          const m4 = resF?.facialTransformationMatrixes?.[0];
          let pose = poseFromMatrixAuto(m4) || poseSimple(face);
          if(pose){
            const rawPitch=pose.pitch, rawYaw=pose.yaw;
            const heur = poseSimple(face);
            if(heur){ const ry=clamp(Math.abs(heur.yaw)/(Math.abs(rawYaw)+1e-3),0.5,6.0); const rp=clamp(Math.abs(heur.pitch)/(Math.abs(rawPitch)+1e-3),0.5,6.0); sYawAuto=ema(sYawAuto,ry,0.08); sPitchAuto=ema(sPitchAuto,rp,0.08); }
            pitchEMA=ema(pitchEMA,rawPitch); yawEMA=ema(yawEMA,rawYaw);
            const pVal=Number.isFinite(pitchEMA)?pitchEMA:0; const yVal=Number.isFinite(yawEMA)?yawEMA:0;
            const yScale=(Number(poseGainEl?.value)||1.2)*(Number(yawGainEl?.value)||2.0)*sYawAuto;
            const pScale=(Number(poseGainEl?.value)||1.2)*(Number(pitchGainEl?.value)||1.4)*sPitchAuto;
            pitch = clamp((pVal - pitchOffset) * pScale, -60, 60);
            yaw   = clamp((yVal - yawOffset) * yScale,  -90, 90);
            if(flipYaw) yaw=-yaw; if(flipPitch) pitch=-pitch;
            pitch = medianPush(winPitch,pitch); yaw = medianPush(winYaw,yaw);
            scaleDbg.textContent = `auto‑scale: yaw×${(sYawAuto||1).toFixed(2)} pitch×${(sPitchAuto||1).toFixed(2)}`;
          }

          // Adaptive baselines for eye/yawn
          const EAR = ear(face, L.LEFT_EYE)*0.5 + ear(face, L.RIGHT_EYE)*0.5;
          const MAR = mar(face, L.MOUTH);
          if(warmupFrames>0){ earBase=ema(earBase,EAR,0.05); marBase=ema(marBase,MAR,0.05); warmupFrames--; }
          const eyeCut = earBase? Math.max(0.08, earBase*0.65) : THRESH.EYE_CLOSED;
          const yawnCut = marBase? Math.max(0.45, marBase*1.35) : THRESH.YAWN;
          if(EAR < eyeCut){ if(eyeStart==null) eyeStart=now; else if((now-eyeStart)/1000>THRESH.EYE_CLOSED_SEC) eyeAlert=true; eyeStatus='Eyes Closed'; }
          else { eyeStatus='Eyes Open'; eyeStart=null; }
          if(MAR > yawnCut){ if(yawnStart==null) yawnStart=now; else if((now-yawnStart)/1000>THRESH.YAWN_SEC) yawnAlert=true; yawnStatus='Yawning'; }
          else { yawnStatus='No Yawn'; yawnStart=null; }

          if(Number.isFinite(yaw)){
            if(yaw > Math.abs(THRESH.YAW_LEFT)) headLR='Turn Right'; else if(yaw < THRESH.YAW_RIGHT) headLR='Turn Left'; else headLR='Center';
            if(headLR!=='Center'){ if(yawStart==null) yawStart=now; else if((now-yawStart)/1000>THRESH.HOLD_SEC) yawAlertText=headLR; } else yawStart=null;
          }
          if(Number.isFinite(pitch)){
            if(pitch > THRESH.PITCH_DOWN) headUD='Head Down'; else if(pitch < THRESH.PITCH_UP) headUD='Head Up'; else headUD='Center';
            if(headUD!=='Center'){ if(pitchStart==null) pitchStart=now; else if((now-pitchStart)/1000>THRESH.HOLD_SEC) pitchAlertText=headUD; } else pitchStart=null;
          }
        } else { yawStart=null; pitchStart=null; dbgMode.textContent='matrix: waiting (no face)'; }

        const {count,both}=handsAboveFace(hands, face);
        handStatus = count? `${count} Hand(s) Above Face` : `${hands.length} Hand(s)`;
        if(both){ if(handsStart==null) handsStart=now; else if((now-handsStart)/1000>THRESH.BOTH_HANDS_UP_SEC) handsAlert=true; } else handsStart=null;

        // Phone detection (always enabled by default in settings)
        frameCount++;
        const phoneEnabled = !!(swPhone && swPhone.checked);
        const requireHandOverlap = !!(swPhoneOverlap && swPhoneOverlap.checked);
        let phoneBoxes = lastPhoneDetections;
        if(phoneEnabled && phoneReady && (frameCount % THRESH.PHONE_CADENCE === 0)){
          const r = objDetector.detectForVideo(video, now);
          const boxes=[];
          for(const det of (r?.detections || [])){
            const cat = det.categories?.[0]; if(!cat) continue;
            const name=(cat.categoryName||'').toLowerCase(); if(name!=="cell phone") continue;
            const bb=det.boundingBox; boxes.push({xMin:bb.originX,yMin:bb.originY,xMax:bb.originX+bb.width,yMax:bb.originY+bb.height,score:cat.score||0});
          }
          phoneBoxes = boxes; lastPhoneDetections = boxes;
        }
        if(phoneBoxes?.length){ ctx.save(); ctx.lineWidth=2; ctx.strokeStyle='rgba(234,179,8,0.95)'; ctx.fillStyle='rgba(234,179,8,0.15)'; for(const b of phoneBoxes){ const w=canvas.width; const bw=b.xMax-b.xMin; const bh=b.yMax-b.yMin; const mx=w-(b.xMin+bw); ctx.fillRect(mx,b.yMin,bw,bh); ctx.strokeRect(mx,b.yMin,bw,bh);} ctx.restore(); }

        if(phoneEnabled && phoneBoxes?.length){
          if(requireHandOverlap){
            const w=canvas.width,h=canvas.height; let overlap=false;
            outer: for(const hnd of hands){
              const pts=hnd.map(p=>({x:p.x*w,y:p.y*h}));
              for(const p of pts){
                for(const b of phoneBoxes){ if(p.x>=b.xMin && p.x<=b.xMax && p.y>=b.yMin && p.y<=b.yMax){ overlap=true; break outer; } }
              }
            }
            phone = overlap;
          } else { phone = true; }
        } else { phone=false; }
        phoneAlert = phone;

        updateUI({ pitch,yaw,headLR,headUD,eyeStatus,yawnStatus,handStatus,phone, eyeAlert,yawnAlert,handsAlert,phoneAlert, yawAlertText,pitchAlertText });

      }catch(e){ console.error('loop error',e); }
      finally{ isBusy=false; scheduleNext(loop); }
    }

    // --- Events & onboarding
    function syncRange(el,label){ const v=Number(el?.value); if(!label) return; label.textContent = `${(Number.isFinite(v)? v:1).toFixed(2)}×`; }
    ;[poseGainEl,yawGainEl,pitchGainEl].forEach((el,i)=>{ if(!el) return; const labels=[poseGainLabel,yawGainLabel,pitchGainLabel]; el.addEventListener('input',()=>syncRange(el,labels[i])); syncRange(el,labels[i]); });

    // defaults
    swFlipYaw.checked = true; swFlipPitch.checked = true; swPhone.checked = true; swPhoneOverlap.checked = true;

    btnSettings.addEventListener('click', ()=> sheet.classList.add('open'));
    btnCloseSheet.addEventListener('click', ()=> sheet.classList.remove('open'));

    // Robust Calibrate: actively looks for a face up to 2s
    btnCalib.addEventListener('click', async ()=>{
      btnCalib.disabled = true;
      try{
        if(!video.srcObject){ try{ await startCam(); }catch{} }
        if(!modelsReady){ try{ await initModels(); }catch{} }

        const deadline = performance.now() + 2000; // wait up to 2s
        let got = false, lastPose = null;
        while(performance.now() < deadline){
          const now = performance.now();
          const resF = faceLandmarker?.detectForVideo?.(video, now);
          const face = resF?.faceLandmarks?.[0] || null;
          if(face){
            const m4 = resF?.facialTransformationMatrixes?.[0];
            const pose = poseFromMatrixAuto(m4) || poseSimple(face);
            if(pose && Number.isFinite(pose.pitch) && Number.isFinite(pose.yaw)){ lastPose = pose; got = true; break; }
          }
          await new Promise(r => requestAnimationFrame(()=>r()));
        }

        if(!got){ showToast('ยังไม่พบหน้าในกรอบ • ขยับให้อยู่กลางภาพ/เพิ่มแสง', false); return; }
        const usePitch = Number.isFinite(pitchEMA) ? pitchEMA : lastPose.pitch;
        const useYaw   = Number.isFinite(yawEMA)   ? yawEMA   : lastPose.yaw;
        pitchOffset = usePitch; yawOffset = useYaw; calibrated = true; btnToggle.disabled = false;
        canvas.style.outline = '3px solid #10b981'; setTimeout(()=>{ canvas.style.outline = 'none'; }, 520);
        showToast('Calibrated! พร้อมเริ่มใช้งาน');
      } finally { btnCalib.disabled = false; }
    });

    btnToggle.addEventListener('click', async ()=>{
      if(!isRunning){
        [sndEyes,sndYawn,sndHands,sndPhone].forEach(a=>{ a.play().then(()=>{a.pause();a.currentTime=0;}).catch(()=>{}); });
        try{
          if(!video.srcObject) await startCam();
          if(!modelsReady) await initModels();
          if(!calibrated){ showToast('กด Calibrate ก่อนเริ่ม', false); return; }
          isRunning = true; btnToggle.textContent='Stop';
          scheduleNext(loop);
        }catch(err){ console.error(err); showToast('เริ่มไม่สำเร็จ: อนุญาตกล้อง/อินเทอร์เน็ต', false); }
      } else {
        isRunning = false; btnToggle.textContent='Start';
        stopAll(); try{ await navigator.wakeLock?.request('screen')?.release?.(); }catch{}
        const s = video.srcObject; if(s){ s.getTracks().forEach(t=>t.stop()); video.srcObject=null; }
        ctx.clearRect(0,0,canvas.width,canvas.height);
        showToast('หยุดการตรวจจับ');
      }
    });

    swFlipYaw.addEventListener('change', ()=>{ flipYaw = swFlipYaw.checked; showToast(`Flip Yaw: ${flipYaw?'ON':'OFF'}`); });
    swFlipPitch.addEventListener('change', ()=>{ flipPitch = swFlipPitch.checked; showToast(`Flip Pitch: ${flipPitch?'ON':'OFF'}`); });

    // Auto start camera to let user calibrate immediately
    (async ()=>{ try{ await startCam(); await initModels(); showToast('ยืนตรง มองกล้อง แล้วกด Calibrate'); }catch{} })();
  </script>
</body>
</html>