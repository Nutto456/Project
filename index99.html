<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
  <title>Drowsiness Detection – 2 Hands + Wheel ONNX</title>
  <link rel="icon" href="data:,">
  <!-- Tailwind (CDN ok for dev; for prod use CLI/PostCSS) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- ONNX Runtime Web -->
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.20.0/dist/ort.min.js"></script>
  <style>
    :root { --safe-inset-bottom: env(safe-area-inset-bottom); }
    body { font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; }
    .video-wrap { position: relative; width: 100%; max-width: 560px; aspect-ratio: 3/4; }
    @media (max-width: 768px){ .video-wrap{ max-width:100%; aspect-ratio: unset; height: calc(100dvh - 184px); } }
    #video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
    #overlay { position: absolute; inset: 0; transform: scaleX(-1); }
    .sheet { position: fixed; inset: auto 0 0 0; background: white; border-top-left-radius: 1.25rem; border-top-right-radius: 1.25rem; box-shadow: 0 -16px 40px rgba(2,6,23,.2); transform: translateY(100%); transition: transform .25s ease; }
    .sheet.open { transform: translateY(0); }
    .action-bar { position: sticky; bottom: 0; inset-inline: 0; padding-bottom: calc(var(--safe-inset-bottom) + .5rem); }
    .badge { display:inline-block; padding:.15rem .5rem; border-radius:999px; font-size:.75rem; }
    .subtle { font-size:.80rem; color:#334155 }
    canvas { image-rendering: crisp-edges; }
  </style>
</head>
<body class="bg-slate-50 min-h-screen">
  <div id="toast" class="hidden fixed top-3 right-3 z-50 px-4 py-2 rounded-lg text-white shadow"></div>

  <main class="mx-auto max-w-5xl p-4">
    <header class="mb-3 text-center">
      <h1 class="text-2xl md:text-3xl font-bold">Drowsiness Detection</h1>
      <p class="text-slate-600 text-sm">หน้าเดียว ใช้งานง่าย • <span class="font-semibold">Calibrate ก่อนเริ่ม</span></p>
    </header>

    <section class="video-wrap mx-auto rounded-xl overflow-hidden bg-gray-200">
      <video id="video" autoplay playsinline muted></video>
      <canvas id="overlay"></canvas>
    </section>

    <!-- Status -->
    <section class="mt-3 grid grid-cols-2 gap-2 text-sm">
      <div class="col-span-2 flex flex-wrap gap-2 items-center">
        <span class="badge bg-blue-600 text-white" id="safeBadge">Head Pose: ON</span>
        <span class="badge bg-slate-200 text-slate-700" id="dbgMode">matrix: auto</span>
        <span class="badge bg-slate-200 text-slate-700" id="camBadge">cam: ?</span>
        <span class="badge bg-slate-200 text-slate-700" id="modelBadge">models: ?</span>
        <span class="badge bg-slate-200 text-slate-700" id="faceBadge">faces: 0</span>
      </div>
      
      <div class="col-span-2">Wheel: <span id="wheelOut" class="font-semibold">-</span></div>
      <p class="col-span-2 text-xs text-slate-500" id="scaleDbg">auto-scale: yaw×1.00 pitch×1.00</p>
    </section>

    <!-- Alerts -->
    <section id="alertBox" class="hidden mt-3 p-3 rounded-xl bg-red-50 text-red-800 font-semibold"></section>

    <!-- Bottom actions -->
    <section class="action-bar bg-white/90 backdrop-blur rounded-xl border border-slate-200 p-3 mt-3 flex items-center gap-2">
      <button id="btnCalib" class="px-4 py-2 rounded-xl text-white bg-indigo-600 hover:bg-indigo-700 font-semibold shadow flex-1">Calibrate</button>
      <button id="btnToggle" class="px-4 py-2 rounded-xl text-white bg-blue-600 hover:bg-blue-700 font-semibold shadow flex-1" disabled>Start</button>
      <button id="btnSettings" class="px-4 py-2 rounded-xl bg-slate-100 hover:bg-slate-200 font-semibold shadow">ตั้งค่า</button>
      <button id="btnFullscreen" class="px-4 py-2 rounded-xl bg-slate-100 hover:bg-slate-200 font-semibold shadow">Fullscreen</button>
    </section>
  </main>

  <!-- Settings Sheet -->
  <div id="sheet" class="sheet p-4">
    <div class="mx-auto max-w-xl">
      <div class="flex items-center justify-between mb-2">
        <h2 class="text-lg font-bold">ตั้งค่า</h2>
        <button id="btnCloseSheet" class="px-3 py-1 rounded-lg bg-slate-100">ปิด</button>
      </div>
      <div class="space-y-4 text-sm">
        <label class="flex items-center justify-between">
          <span>Flip Yaw</span>
          <input id="swFlipYaw" type="checkbox" class="scale-125" checked>
        </label>
        <label class="flex items-center justify-between">
          <span>Flip Pitch</span>
          <input id="swFlipPitch" type="checkbox" class="scale-125" checked>
        </label>
        <label class="flex items-center justify-between">
          <span>Phone Detector</span>
          <input id="swPhone" type="checkbox" class="scale-125" checked>
        </label>
        <label class="flex items-center justify-between">
          <span>นับว่า "กำลังใช้โทรศัพท์" เมื่อมือทับกรอบโทรศัพท์</span>
          <input id="swPhoneOverlap" type="checkbox" class="scale-125" checked>
        </label>
        <label class="flex items-center justify-between">
          <span>Invert Wheel Label (สลับ On/Off)</span>
          <input id="swInvertWheel" type="checkbox" class="scale-125">
        </label>
        <details>
          <summary class="cursor-pointer select-none font-semibold">ขั้นสูง</summary>
          <div class="mt-2 space-y-3">
            <label class="flex items-center justify-between gap-3"><span>FPS</span>
              <select id="fps" class="border rounded px-2 py-1">
                <option>24</option>
                <option selected>30</option>
                <option>20</option>
                <option>15</option>
              </select>
              <span id="cpuHint" class="text-xs text-slate-500"></span>
            </label>
            <label class="flex items-center justify-between gap-3"><span>Pose Gain</span>
              <input id="poseGain" type="range" min="0.80" max="2.00" step="0.05" value="1.20" class="w-40">
              <span id="poseGainLabel" class="tabular-nums">1.20×</span>
            </label>
            <label class="flex items-center justify-between gap-3"><span>Yaw Gain</span>
              <input id="yawGain" type="range" min="0.50" max="4.00" step="0.10" value="2.00" class="w-40">
              <span id="yawGainLabel" class="tabular-nums">2.00×</span>
            </label>
            <label class="flex items-center justify-between gap-3"><span>Pitch Gain</span>
              <input id="pitchGain" type="range" min="0.50" max="4.00" step="0.10" value="1.40" class="w-40">
              <span id="pitchGainLabel" class="tabular-nums">1.40×</span>
            </label>
          </div>
        </details>
      </div>
    </div>
  </div>

  <!-- sounds -->
  <audio id="sndEyes"  src="./static/Sound/eyeclosed_alert.mp3" preload="auto"></audio>
  <audio id="sndYawn"  src="./static/Sound/Yawn_alert.mp3" preload="auto"></audio>
  <audio id="sndHands" src="./static/Sound/both_hand_alert.mp3" preload="auto"></audio>
  <audio id="sndPhone" src="./static/Sound/phone_alert.mp3" preload="auto"></audio>

  <script type="module">
    import { FaceLandmarker, HandLandmarker, ObjectDetector, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14";

    // === Elements
    const video = document.getElementById('video');
    const canvas = document.getElementById('overlay');
    const ctx = canvas.getContext('2d');

    const btnToggle = document.getElementById('btnToggle');
    const btnCalib = document.getElementById('btnCalib');
    const btnFullscreen = document.getElementById('btnFullscreen');
    const btnSettings = document.getElementById('btnSettings');
    const sheet = document.getElementById('sheet');
    const btnCloseSheet = document.getElementById('btnCloseSheet');

    const swFlipYaw = document.getElementById('swFlipYaw');
    const swFlipPitch = document.getElementById('swFlipPitch');
    const swPhone = document.getElementById('swPhone');
    const swPhoneOverlap = document.getElementById('swPhoneOverlap');
    const swInvertWheel = document.getElementById('swInvertWheel');

    const fpsSel = document.getElementById('fps');
    const poseGainEl = document.getElementById('poseGain');
    const yawGainEl = document.getElementById('yawGain');
    const pitchGainEl = document.getElementById('pitchGain');
    const poseGainLabel = document.getElementById('poseGainLabel');
    const yawGainLabel = document.getElementById('yawGainLabel');
    const pitchGainLabel = document.getElementById('pitchGainLabel');

    const dbgMode = document.getElementById('dbgMode');
    const camBadge = document.getElementById('camBadge');
    const modelBadge = document.getElementById('modelBadge');
    const faceBadge = document.getElementById('faceBadge');
    const scaleDbg = document.getElementById('scaleDbg');
    const cpuHint = document.getElementById('cpuHint');
    const toast = document.getElementById('toast');
    const alertBox = document.getElementById('alertBox');

    const pitchOut = document.getElementById('pitchOut');
    const yawOut   = document.getElementById('yawOut');
    const headLROut = document.getElementById('headLROut');
    const headUDOut = document.getElementById('headUDOut');
    const eyesOut  = document.getElementById('eyesOut');
    const yawnOut  = document.getElementById('yawnOut');
    const handsOut = document.getElementById('handsOut');
    const phoneOut = document.getElementById('phoneOut');
    const wheelOut = document.getElementById('wheelOut');
    const blinkOut = document.getElementById('blinkOut');
    

    const sndEyes  = document.getElementById('sndEyes');
    const sndYawn  = document.getElementById('sndYawn');
    const sndHands = document.getElementById('sndHands');
    const sndPhone = document.getElementById('sndPhone');

    // === Config
    const THRESH = {
      EYE_CLOSED: 0.13,
      YAWN: 0.60,
      EYE_CLOSED_SEC: 1.0,
      YAWN_SEC: 2.5,
      BOTH_HANDS_UP_SEC: 2,
      PITCH_DOWN: 15,
      PITCH_UP: -18,
      YAW_LEFT: 10,
      YAW_RIGHT: -15,
      HOLD_SEC: 1.0,
      PHONE_SCORE: 0.50,
      PHONE_CADENCE: 12
    };
    const BLINK = { MIN: 0.05, MAX: 0.40, WIN_SEC: 60 };
    const PERCLOS = { WIN_SEC: 30, ALERT: 0.20 };

    // === State
    let isRunning = false, isBusy = false, lastTick = 0;
    let calibrated = false;
    let flipYaw = true, flipPitch = true;

    let faceLandmarker, handLandmarker, objDetector;
    let modelsReady = false, phoneReady = false;

    let pitchOffset=0, yawOffset=0;
    let pitchEMA=null, yawEMA=null, rollEMA=null;
    let eyeStart=null, yawnStart=null, handsStart=null, yawStart=null, pitchStart=null;
    let playing = new Set();

    let frameCount = 0; let lastPhoneDetections = [];

    // Wheel state machine (no 'Unknown', with hysteresis)
    let wheelState = false;        // false=Off, true=On
    let wheelSeenHandsTS = 0;      // last timestamp hands seen
    let wheelOffGraceSec = 0.6;    // grace after hands disappear
    let wheelScoreEMA = 0;         // smoothed score 0..1
    

    let sYawAuto = 1.0, sPitchAuto = 1.0;
    let warmupFrames = 90; let earBase=null, marBase=null;

    const winYaw=[], winPitch=[]; const WIN=5;

    // Blink / PERCLOS / Face lost
    let blinkTimes = [];
    let eyeClosedNow = false, eyeClosedStart = 0;
    let 

        } else {
          yawStart=null; pitchStart=null; dbgMode.textContent='matrix: waiting (no face)';
          const t = now/1000;
          if(!faceLastSeen) faceLastSeen = t;
          faceLost = (t - faceLastSeen > 2.0);
        }

        // hands info
        const handsCount = resH?.landmarks?.length || 0;
        handStatus = `${handsCount} Hand(s)`;

        // Phone detection
        frameCount++;
        const phoneEnabled = !!(swPhone && swPhone.checked);
        const requireHandOverlap = !!(swPhoneOverlap && swPhoneOverlap.checked);
        let phoneBoxes = lastPhoneDetections;
        if(phoneEnabled && phoneReady && (frameCount % THRESH.PHONE_CADENCE === 0)){
          const r = objDetector.detectForVideo(video, now);
          const boxes=[];
          for(const det of (r?.detections || [])){
            const cat = det.categories?.[0]; if(!cat) continue;
            const name=(cat.categoryName||'').toLowerCase(); if(name!=="cell phone") continue;
            const bb=det.boundingBox; boxes.push({xMin:bb.originX,yMin:bb.originY,xMax:bb.originX+bb.width,yMax:bb.originY+bb.height,score:cat.score||0});
          }
          phoneBoxes = boxes; lastPhoneDetections = boxes;
        }
        if(phoneBoxes?.length){
          ctx.save(); ctx.lineWidth=2; ctx.strokeStyle='rgba(234,179,8,0.95)'; ctx.fillStyle='rgba(234,179,8,0.15)';
          for(const b of phoneBoxes){
            const w=canvas.width; const bw=b.xMax-b.xMin; const bh=b.yMax-b.yMin; const mx=w-(b.xMin+bw);
            ctx.fillRect(mx,b.yMin,bw,bh); ctx.strokeRect(mx,b.yMin,bw,bh);
          }
          ctx.restore();
        }
        if(phoneEnabled && phoneBoxes?.length){
          if(requireHandOverlap){
            const w=canvas.width,h=canvas.height; let overlap=false;
            outer: for(const hnd of hands){
              const pts=hnd.lm.map(p=>({x:p.x*w,y:p.y*h}));
              for(const p of pts){
                for(const b of phoneBoxes){ if(p.x>=b.xMin && p.x<=b.xMax && p.y>=b.yMin && p.y<=b.yMax){ overlap=true; break outer; } }
              }
            }
            phone = overlap;
          } else { phone = true; }
        } else { phone=false; }
        phoneAlert = phone;

        // Draw hands debug (optional)
        drawHands(hands);

        
// Wheel ONNX (+fallback) + state (no 'Unknown')
let wheelOn = null, wheelScore = 0.0;
{
  // Base score from ONNX or heuristic
  let baseScore = 0.0;
  let gotScore = false;
  if (WHEEL.ready) {
    const pred = await wheelPredict(hands);
    if (pred.ok && pred.on !== null && Number.isFinite(pred.score)) {
      baseScore = pred.on ? pred.score : (1.0 - pred.score);
      // If model says on=false with high conf, reflect that
      baseScore = pred.on ? Math.max(baseScore, 0.5) : Math.min(baseScore, 0.5);
      gotScore = true;
    }
  }
  if (!gotScore) {
    const fb = heuristicWheel(hands);
    if (fb.on !== null && Number.isFinite(fb.score)) {
      baseScore = fb.on ? fb.score : (1.0 - fb.score);
      gotScore = true;
    }
  }

  // Hand presence & position gating
  const nowSec = performance.now() / 1000;
  const handsCount = hands?.length || 0;
  if (handsCount > 0) wheelSeenHandsTS = nowSec;

  // Penalize when hands are high (you raised your hand)
  let posPenalty = 0.0;
  for (const hnd of hands) {
    const ys = hnd.lm.map(p => p.y);
    const minY = Math.min(...ys);
    const maxY = Math.max(...ys);
    const wristY = hnd.lm[0]?.y ?? 1.0;
    if (minY < 0.45) posPenalty += 0.25; // hand up high
    if (wristY < 0.55) posPenalty += 0.20; // wrist not low enough
    if (maxY > 0.95) posPenalty += 0.05;  // too low -> likely off screen
  }
  posPenalty = Math.min(0.8, posPenalty);

  let score = Math.max(0, Math.min(1, baseScore * (1 - posPenalty)));

  // Smooth score
  wheelScoreEMA = (wheelScoreEMA === 0) ? score : (0.25 * score + 0.75 * wheelScoreEMA);

  // Hysteresis thresholds
  const TH_ON = 0.62, TH_OFF = 0.48;

  // If no hands for a moment -> OFF (no 'Unknown')
  const noHandsTooLong = (nowSec - wheelSeenHandsTS) > wheelOffGraceSec;
  if (noHandsTooLong) {
    wheelState = false;
  } else {
    if (!wheelState && wheelScoreEMA >= TH_ON) wheelState = true;
    if (wheelState && wheelScoreEMA <= TH_OFF) wheelState = false;
  }

  wheelOn = wheelState;
  wheelScore = wheelScoreEMA;
}

const wheelStatus = wheelOn ? 'On Wheel' : 'Off Wheel';

updateUI({ pitch,yaw,headLR,headUD,eyeStatus,yawnStatus,handStatus,phone, eyeAlert,yawnAlert,handsAlert,phoneAlert, yawAlertText,pitchAlertText, wheelStatus, wheelAlert:false, blinkText, faceLost });
{ pitch,yaw,headLR,headUD,eyeStatus,yawnStatus,handStatus,phone, eyeAlert,yawnAlert,handsAlert,phoneAlert, yawAlertText,pitchAlertText, wheelStatus, wheelAlert, blinkText, faceLost });

      }catch(e){ console.error('loop error',e); }
      finally{ isBusy=false; scheduleNext(loop); }
    }

    // Events & onboarding
    function syncRange(el,label){ const v=Number(el?.value); if(!label) return; label.textContent = `${(Number.isFinite(v)? v:1).toFixed(2)}×`; }
    ;[poseGainEl,yawGainEl,pitchGainEl].forEach((el,i)=>{ if(!el) return; const labels=[poseGainLabel,yawGainLabel,pitchGainLabel]; el.addEventListener('input',()=>syncRange(el,labels[i])); syncRange(el,labels[i]); });

    swFlipYaw.checked = true; swFlipPitch.checked = true; swPhone.checked = true; swPhoneOverlap.checked = true;
    swInvertWheel.addEventListener('change', ()=>{ WHEEL.invert = swInvertWheel.checked; showToast(`Invert Wheel: ${WHEEL.invert?'ON':'OFF'}`); });

    btnSettings.addEventListener('click', ()=> sheet.classList.add('open'));
    btnCloseSheet.addEventListener('click', ()=> sheet.classList.remove('open'));

    btnCalib.addEventListener('click', async ()=>{
      btnCalib.disabled = true;
      try{
        if(!video.srcObject){ try{ await startCam(); }catch{} }
        if(!modelsReady){ try{ await initModels(); }catch{} }
        if(!WHEEL.ready){ try{ await initWheelONNX(); }catch{} }

        const deadline = performance.now() + 2000;
        let got = false, lastPose = null;
        while(performance.now() < deadline){
          const now = performance.now();
          const resF = faceLandmarker?.detectForVideo?.(video, now);
          const face = resF?.faceLandmarks?.[0] || null;
          if(face){
            const m4 = resF?.facialTransformationMatrixes?.[0];
            const pose = poseFromMatrixAuto(m4) || poseSimple(face);
            if(pose && Number.isFinite(pose.pitch) && Number.isFinite(pose.yaw)){ lastPose = pose; got = true; break; }
          }
          await new Promise(r => requestAnimationFrame(()=>r()));
        }

        if(!got){ showToast('ยังไม่พบหน้าในกรอบ • ขยับให้อยู่กลางภาพ/เพิ่มแสง', false); return; }
        const usePitch = Number.isFinite(pitchEMA) ? pitchEMA : lastPose.pitch;
        const useYaw   = Number.isFinite(yawEMA)   ? yawEMA   : lastPose.yaw;
        pitchOffset = usePitch; yawOffset = useYaw; calibrated = true; btnToggle.disabled = false;
        canvas.style.outline = '3px solid #10b981'; setTimeout(()=>{ canvas.style.outline = 'none'; }, 520);
        showToast('Calibrated! พร้อมเริ่มใช้งาน');
      } finally { btnCalib.disabled = false; }
    });

    btnToggle.addEventListener('click', async ()=>{
      if(!isRunning){
        [sndEyes,sndYawn,sndHands,sndPhone].forEach(a=>{ a.play().then(()=>{a.pause();a.currentTime=0;}).catch(()=>{}); });
        try{
          if(!video.srcObject) await startCam();
          if(!modelsReady) await initModels();
          if(!WHEEL.ready) await initWheelONNX();
          if(!calibrated){ showToast('กด Calibrate ก่อนเริ่ม', false); return; }
          isRunning = true; btnToggle.textContent='Stop';
          scheduleNext(loop);
        }catch(err){ console.error(err); showToast('เริ่มไม่สำเร็จ: อนุญาตกล้อง/อินเทอร์เน็ต', false); }
      } else {
        isRunning = false; btnToggle.textContent='Start';
        stopAll();
        const s = video.srcObject; if(s){ s.getTracks().forEach(t=>t.stop()); video.srcObject=null; }
        ctx.clearRect(0,0,canvas.width,canvas.height);
        showToast('หยุดการตรวจจับ');
      }
    });

    btnFullscreen.addEventListener('click', ()=>{
      document.fullscreenElement ? document.exitFullscreen() : document.documentElement.requestFullscreen().catch(()=>{});
    });

    swFlipYaw.addEventListener('change', ()=>{ flipYaw = swFlipYaw.checked; showToast(`Flip Yaw: ${flipYaw?'ON':'OFF'}`); });
    swFlipPitch.addEventListener('change', ()=>{ flipPitch = swFlipPitch.checked; showToast(`Flip Pitch: ${flipPitch?'ON':'OFF'}`); });

    // Auto start camera + preload models
    (async ()=>{
      try{
        await startCam();
        await initModels();
        await initWheelONNX();
        showToast('ยืนตรง มองกล้อง แล้วกด Calibrate');
      }catch{}
    })();
  </script>
</body>
</html>
